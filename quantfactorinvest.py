import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
from openai import OpenAI

# -----------------------------------------------------------------------------
# 1. APP CONFIGURATION & SECRETS
# -----------------------------------------------------------------------------
st.set_page_config(
    page_title="AI Smart Beta Agent",
    page_icon="üß†",
    layout="wide"
)

# Initialize OpenAI Client
# Ensure you have a .streamlit/secrets.toml file with [OPENAI_API_KEY]
api_key = st.secrets.get("OPENAI_API_KEY")
client = None
if api_key:
    client = OpenAI(api_key=api_key)
else:
    st.warning("‚ö†Ô∏è OpenAI API Key not found in secrets. AI Qualitative Analysis will be disabled.")

# -----------------------------------------------------------------------------
# 2. HELPER FUNCTIONS & DATA FETCHING
# -----------------------------------------------------------------------------

@st.cache_data(ttl=3600)
def fetch_market_data(tickers, period="1y"):
    """
    Fetches historical price data and fundamental info for the given tickers.
    """
    data = {}
    price_data = pd.DataFrame()
    
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    for i, ticker in enumerate(tickers):
        status_text.text(f"Fetching data for {ticker}...")
        stock = yf.Ticker(ticker)
        
        # 1. Get Fundamental Info (Value, Quality, Size)
        try:
            info = stock.info
            
            # Extract key metrics with fallbacks
            pe_ratio = info.get('trailingPE', np.nan)          # Value
            pb_ratio = info.get('priceToBook', np.nan)         # Value Alternate
            roe = info.get('returnOnEquity', np.nan)           # Quality
            profit_margin = info.get('profitMargins', np.nan)  # Quality Alternate
            market_cap = info.get('marketCap', np.nan)         # Size
            sector = info.get('sector', 'Unknown')
            short_name = info.get('shortName', ticker)
            
            data[ticker] = {
                'Name': short_name,
                'Sector': sector,
                'P/E': pe_ratio,
                'P/B': pb_ratio,
                'ROE': roe,
                'Profit Margin': profit_margin,
                'Market Cap': market_cap
            }
            
        except Exception as e:
            # print(f"Error fetching info for {ticker}: {e}") # Debugging
            data[ticker] = {
                'Name': ticker, 'Sector': 'Error',
                'P/E': np.nan, 'P/B': np.nan, 'ROE': np.nan, 
                'Profit Margin': np.nan, 'Market Cap': np.nan
            }

        # 2. Get Historical Price (for Volatility)
        try:
            hist = stock.history(period=period)
            if not hist.empty:
                price_data[ticker] = hist['Close']
        except Exception as e:
            pass # print(f"Error fetching history for {ticker}: {e}")
            
        progress_bar.progress((i + 1) / len(tickers))

    progress_bar.empty()
    status_text.empty()
    
    fundamentals_df = pd.DataFrame(data).T
    return fundamentals_df, price_data

def calculate_volatility(price_data):
    """
    Calculates annualized volatility (standard deviation of daily returns).
    """
    returns = price_data.pct_change().dropna()
    volatility = returns.std() * np.sqrt(252)
    return volatility

def calculate_z_scores(df, columns):
    """
    Normalizes selected columns using Z-Score: (x - mean) / std_dev.
    """
    df_z = df.copy()
    for col in columns:
        if col in df_z.columns:
            series = df_z[col].fillna(df_z[col].median())
            # Avoid division by zero if std is 0
            std = series.std()
            if std == 0:
                df_z[f'{col}_Z'] = 0
            else:
                df_z[f'{col}_Z'] = (series - series.mean()) / std
    return df_z

def get_ai_analysis(top_stocks, weights, strategy_description):
    """
    Sends the quantitative results to OpenAI for a qualitative overlay.
    """
    if not client:
        return "AI Client not initialized."

    # Construct the prompt data
    stock_summary = top_stocks[['Name', 'Sector', 'Composite_Score', 'P/E', 'ROE', 'Volatility']].to_string()
    
    prompt = f"""
    You are a Senior Portfolio Manager at a Quant Hedge Fund. 
    
    You have just run a Smart Beta factor model with the following strategy weights:
    {weights}
    
    The strategy description is: {strategy_description}
    
    Here are the Top Picks generated by the model (Quantitative Output):
    {stock_summary}
    
    Please provide a concise analysis (markdown format) covering:
    1. **Portfolio Personality:** Based on the weights and the resulting stocks, what is the 'character' of this portfolio? (e.g., Defensive, Aggressive, Value-Trap prone?)
    2. **Sector Exposure Risks:** Are we accidentally over-exposed to one sector?
    3. **Stock Specific Logic:** Briefly explain why the top 2 stocks likely scored high given the specific weights (e.g., "X scored high because you heavily weighted Low Volatility").
    4. **The Bear Case:** What market environment would cause this specific portfolio to underperform?
    
    Be professional, direct, and insightful. Do not explain what a P/E ratio is. Assume I am a professional.
    """
    
    try:
        response = client.chat.completions.create(
            model="gpt-4o", # Or gpt-3.5-turbo if 4o is unavailable
            messages=[
                {"role": "system", "content": "You are an expert financial analyst."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7
        )
        return response.choices[0].message.content
    except Exception as e:
        return f"Error generating AI analysis: {e}"

# -----------------------------------------------------------------------------
# 3. SIDEBAR & USER INPUTS
# -----------------------------------------------------------------------------

st.sidebar.header("üîß Agent Configuration")

default_tickers = "AAPL, MSFT, GOOGL, AMZN, NVDA, TSLA, JPM, JNJ, V, PG, XOM, UNH, MA, HD, CVX, ABBV, MRK, KO, PEP, BAC, WMT, COST, MCD, DIS, NKE"
ticker_input = st.sidebar.text_area("Universe (Comma separated)", value=default_tickers, height=150)
tickers_list = [x.strip().upper() for x in ticker_input.split(',') if x.strip()]

st.sidebar.subheader("‚öñÔ∏è Factor Weights")
st.sidebar.info("Adjust importance (0-10).")

w_value = st.sidebar.slider("Value (Low P/E)", 0.0, 10.0, 5.0)
w_quality = st.sidebar.slider("Quality (High ROE)", 0.0, 10.0, 5.0)
w_size = st.sidebar.slider("Size (Low Market Cap)", 0.0, 10.0, 2.0)
w_vol = st.sidebar.slider("Low Volatility", 0.0, 10.0, 5.0)

st.sidebar.subheader("‚öôÔ∏è Backtest Settings")
lookback_period = st.sidebar.selectbox("Lookback Period", ["6mo", "1y", "2y", "5y"], index=1)
top_n_picks = st.sidebar.number_input("Select Top N Stocks", min_value=1, max_value=20, value=5)

# -----------------------------------------------------------------------------
# 4. MAIN APP LOGIC
# -----------------------------------------------------------------------------

st.title("üß† AI-Powered Smart Beta Agent")
st.markdown("""
**Objective:** Construct a factor-based portfolio using Value, Quality, Size, and Low Volatility.
**Process:** 1. Fetch live market data (yfinance). 
2. Compute Z-Scores for every factor. 
3. Rank stocks based on your custom weights.
4. **AI Overlay:** GPT-4 analyzes the resulting portfolio for risks and thesis.
""")

if st.button("üöÄ Run Analysis"):
    if not tickers_list:
        st.error("Please enter at least one ticker.")
    else:
        # --- PHASE 1: DATA GATHERING ---
        with st.spinner('Gathering market intelligence...'):
            fundamentals_df, price_data = fetch_market_data(tickers_list, period=lookback_period)
        
        if fundamentals_df.empty or price_data.empty:
            st.error("Failed to fetch data. Please check ticker symbols.")
        else:
            # --- PHASE 2: QUANTITATIVE ENGINE ---
            
            # Calculate Volatility
            volatility_series = calculate_volatility(price_data)
            fundamentals_df['Volatility'] = volatility_series

            # Clean Data (Numeric conversion & Median Fill)
            clean_df = fundamentals_df.copy()
            numeric_cols = ['P/E', 'ROE', 'Market Cap', 'Volatility']
            
            for col in numeric_cols:
                clean_df[col] = pd.to_numeric(clean_df[col], errors='coerce')
                # Fill NaNs with median of the universe (neutral assumption)
                clean_df[col] = clean_df[col].fillna(clean_df[col].median())

            # Calculate Z-Scores
            clean_df = calculate_z_scores(clean_df, numeric_cols)

            # Apply Factor Direction
            # Value: Low P/E is good -> Invert Z
            # Quality: High ROE is good -> Keep Z
            # Size: Low Cap is good (Small Cap Premium) -> Invert Z
            # Volatility: Low Vol is good -> Invert Z
            
            clean_df['Score_Value'] = clean_df['P/E_Z'] * -1
            clean_df['Score_Quality'] = clean_df['ROE_Z'] * 1
            clean_df['Score_Size'] = clean_df['Market Cap_Z'] * -1
            clean_df['Score_Vol'] = clean_df['Volatility_Z'] * -1

            # Composite Score
            total_weight = w_value + w_quality + w_size + w_vol
            if total_weight == 0: total_weight = 1

            clean_df['Composite_Score'] = (
                (clean_df['Score_Value'] * w_value) +
                (clean_df['Score_Quality'] * w_quality) +
                (clean_df['Score_Size'] * w_size) +
                (clean_df['Score_Vol'] * w_vol)
            ) / total_weight

            # Rank
            clean_df = clean_df.sort_values(by='Composite_Score', ascending=False)
            top_picks = clean_df.head(top_n_picks)
            
            # --- PHASE 3: VISUALIZATION ---
            
            st.divider()
            
            col_left, col_right = st.columns([2, 1])
            
            with col_left:
                st.subheader(f"üèÜ Top {top_n_picks} Recommendations")
                display_cols = ['Name', 'Sector', 'Composite_Score', 'P/E', 'ROE', 'Volatility', 'Market Cap']
                
                # Format for display
                display_df = top_picks[display_cols].copy()
                display_df['Composite_Score'] = display_df['Composite_Score'].round(2)
                display_df['P/E'] = display_df['P/E'].round(2)
                display_df['ROE'] = display_df['ROE'].apply(lambda x: f"{x*100:.2f}%")
                display_df['Volatility'] = display_df['Volatility'].apply(lambda x: f"{x*100:.2f}%")
                
                st.dataframe(
                    display_df.style.background_gradient(subset=['Composite_Score'], cmap='Greens'),
                    use_container_width=True
                )

            with col_right:
                st.subheader("üìä Sector Allocation")
                sector_counts = top_picks['Sector'].value_counts()
                fig_pie = px.pie(values=sector_counts.values, names=sector_counts.index, hole=0.4)
                fig_pie.update_layout(margin=dict(t=0, b=0, l=0, r=0))
                st.plotly_chart(fig_pie, use_container_width=True)

            # --- PHASE 4: BACKTEST PERFORMANCE ---
            
            st.subheader("üìà Historical Simulation (Rebased to 100)")
            
            top_tickers = top_picks.index.tolist()
            if top_tickers:
                top_prices = price_data[top_tickers]
                universe_prices = price_data
                
                # Calculate cumulative returns
                top_returns = top_prices.pct_change().fillna(0)
                universe_returns = universe_prices.pct_change().fillna(0)
                
                top_portfolio_cum = (1 + top_returns.mean(axis=1)).cumprod() * 100
                universe_cum = (1 + universe_returns.mean(axis=1)).cumprod() * 100
                
                perf_df = pd.DataFrame({
                    "Suggested Portfolio": top_portfolio_cum,
                    "Universe Benchmark": universe_cum
                })
                
                fig_perf = px.line(perf_df, color_discrete_map={"Suggested Portfolio": "#00CC96", "Universe Benchmark": "#EF553B"})
                st.plotly_chart(fig_perf, use_container_width=True)
                
                # Stats
                ret_top = perf_df["Suggested Portfolio"].iloc[-1] - 100
                ret_uni = perf_df["Universe Benchmark"].iloc[-1] - 100
                
                m1, m2, m3 = st.columns(3)
                m1.metric("Alpha (Excess Return)", f"{ret_top - ret_uni:.2f}%")
                m2.metric("Portfolio Return", f"{ret_top:.2f}%")
                m3.metric("Benchmark Return", f"{ret_uni:.2f}%")

            # --- PHASE 5: AI QUALITATIVE ANALYSIS ---
            
            st.divider()
            st.subheader("ü§ñ AI Portfolio Manager Analysis")
            
            if client:
                with st.spinner("Generating qualitative analysis from GPT-4..."):
                    weights_dict = {
                        "Value": w_value,
                        "Quality": w_quality,
                        "Size": w_size,
                        "Low Volatility": w_vol
                    }
                    
                    strategy_desc = "Smart Beta Multi-Factor Model ranking stocks by Z-Score."
                    
                    analysis = get_ai_analysis(top_picks, weights_dict, strategy_desc)
                    st.markdown(analysis)
            else:
                st.info("Add your OpenAI API Key to secrets to unlock the AI Qualitative Analyst.")
